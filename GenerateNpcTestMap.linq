<Query Kind="Program">
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\SerdesNet.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\SerdesNet.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Superpower.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Superpower.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Api.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Api.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Base.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Base.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Config.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Config.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Core.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Core.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Core.Veldrid.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Core.Veldrid.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Formats.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Formats.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Game.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Game.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Game.Veldrid.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Game.Veldrid.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\UAlbion.Scripting.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\UAlbion.Scripting.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.ImageSharp.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.ImageSharp.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.ImGui.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.ImGui.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.MetalBindings.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.MetalBindings.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.OpenGLBindings.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.OpenGLBindings.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.RenderDoc.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.RenderDoc.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.SDL2.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.SDL2.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.SPIRV.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.SPIRV.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.StartupUtilities.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.StartupUtilities.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Veldrid.Utilities.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Veldrid.Utilities.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\vk.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\vk.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.D3DCompiler.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.D3DCompiler.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.Direct3D11.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.Direct3D11.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.DirectX.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.DirectX.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.DXGI.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.DXGI.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.Mathematics.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.Mathematics.dll</Reference>
  <Reference Relative="..\..\build\UAlbion\bin\Debug\net6.0\Vortice.Runtime.COM.dll">C:\Depot\bb\ualbion\build\UAlbion\bin\Debug\net6.0\Vortice.Runtime.COM.dll</Reference>
  <Namespace>SixLabors.ImageSharp</Namespace>
  <Namespace>SixLabors.ImageSharp.Formats.Png</Namespace>
  <Namespace>SixLabors.ImageSharp.PixelFormats</Namespace>
  <Namespace>System.Runtime.InteropServices</Namespace>
  <Namespace>UAlbion</Namespace>
  <Namespace>UAlbion.Api</Namespace>
  <Namespace>UAlbion.Api.Visual</Namespace>
  <Namespace>UAlbion.Config</Namespace>
  <Namespace>UAlbion.Game.Veldrid.Assets</Namespace>
  <Namespace>UAlbion.Core.Visual</Namespace>
  <Namespace>UAlbion.Formats.Assets.Maps</Namespace>
  <Namespace>UAlbion.Game.Assets</Namespace>
  <Namespace>System.Text.Json</Namespace>
  <Namespace>UAlbion.Formats.Assets</Namespace>
  <Namespace>UAlbion.Scripting</Namespace>
  <Namespace>UAlbion.Formats</Namespace>
  <RuntimeVersion>6.0</RuntimeVersion>
</Query>

const string FontInfoPath = @"C:\Depot\bb\ualbion\mods\UATestDev\Fonts.json";
const string FontPngPath = @"C:\Depot\bb\ualbion\mods\UATestDev\Fonts.png";
const int TileWidth = 16;
const int TileHeight = 16;

// Common colors
const byte CBlack1 = (byte)CommonColor.Black1; const byte CBlack2 = (byte)CommonColor.Black2; const byte CWhite = (byte)CommonColor.White; const byte CBlueGrey7 = (byte)CommonColor.BlueGrey7; const byte CBlueGrey6 = (byte)CommonColor.BlueGrey6; const byte CBlueGrey5 = (byte)CommonColor.BlueGrey5; const byte CBlueGrey4 = (byte)CommonColor.BlueGrey4; const byte CBlueGrey3 = (byte)CommonColor.BlueGrey3; const byte CBlueGrey2 = (byte)CommonColor.BlueGrey2; const byte CBlueGrey1 = (byte)CommonColor.BlueGrey1; const byte CLavender = (byte)CommonColor.Lavender; const byte CPurple = (byte)CommonColor.Purple; const byte CReddishBlue = (byte)CommonColor.ReddishBlue; const byte CBluishRed = (byte)CommonColor.BluishRed; const byte CLightBurgundy = (byte)CommonColor.LightBurgundy; const byte CBurgundy = (byte)CommonColor.Burgundy; const byte COrange5 = (byte)CommonColor.Orange5; const byte COrange4 = (byte)CommonColor.Orange4; const byte COrange3 = (byte)CommonColor.Orange3; const byte COrange2 = (byte)CommonColor.Orange2; const byte COrange1 = (byte)CommonColor.Orange1; const byte CGreen6 = (byte)CommonColor.Green6; const byte CGreen5 = (byte)CommonColor.Green5; const byte CGreen4 = (byte)CommonColor.Green4; const byte CGreen3 = (byte)CommonColor.Green3; const byte CGreen2 = (byte)CommonColor.Green2; const byte CGreen1 = (byte)CommonColor.Green1; const byte CYellow5 = (byte)CommonColor.Yellow5; const byte CYellow4 = (byte)CommonColor.Yellow4; const byte CYellow3 = (byte)CommonColor.Yellow3; const byte CYellow2 = (byte)CommonColor.Yellow2; const byte CYellow1 = (byte)CommonColor.Yellow1; const byte CTeal4 = (byte)CommonColor.Teal4; const byte CTeal3 = (byte)CommonColor.Teal3; const byte CTeal2 = (byte)CommonColor.Teal2; const byte CTeal1 = (byte)CommonColor.Teal1; const byte CBlue4 = (byte)CommonColor.Blue4; const byte CBlue3 = (byte)CommonColor.Blue3; const byte CBlue2 = (byte)CommonColor.Blue2; const byte CBlue1 = (byte)CommonColor.Blue1; const byte CFlesh8 = (byte)CommonColor.Flesh8; const byte CFlesh7 = (byte)CommonColor.Flesh7; const byte CFlesh6 = (byte)CommonColor.Flesh6; const byte CFlesh5 = (byte)CommonColor.Flesh5; const byte CFlesh4 = (byte)CommonColor.Flesh4; const byte CFlesh3 = (byte)CommonColor.Flesh3; const byte CFlesh2 = (byte)CommonColor.Flesh2; const byte CFlesh1 = (byte)CommonColor.Flesh1; const byte CGrey1 = (byte)CommonColor.Grey1; const byte CGrey2 = (byte)CommonColor.Grey2; const byte CGrey3 = (byte)CommonColor.Grey3; const byte CGrey4 = (byte)CommonColor.Grey4; const byte CGrey5 = (byte)CommonColor.Grey5; const byte CGrey6 = (byte)CommonColor.Grey6; const byte CGrey7 = (byte)CommonColor.Grey7; const byte CGrey8 = (byte)CommonColor.Grey8; const byte CGrey9 = (byte)CommonColor.Grey9; const byte CGrey10 = (byte)CommonColor.Grey10; const byte CGrey11 = (byte)CommonColor.Grey11; const byte CGrey12 = (byte)CommonColor.Grey12; const byte CGrey13 = (byte)CommonColor.Grey13; const byte CGrey14 = (byte)CommonColor.Grey14; const byte CGrey15 = (byte)CommonColor.Grey15; const byte CMidGrey = (byte)CommonColor.MidGrey;
public static readonly uint[] RawPalette = new uint[]  {
0, 0, 0, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295, 4294967295,
	4278190080,	4278190080,	4294967295,	4292337639,	4290494403,	4288913307,	4287594359,	4285751127,
	4283645751,	4281802519,	4290218907,	4288635763,	4286792507,	4286542743,	4284697483,	4283377527,
	4279474151,	4278215619,	4278206375,	4278198143,	4278195039,	4280526759,	4281303927,	4280509251,
	4280764191,	4280756992,	4279965440,	4285785087,	4281582567,	4281049039,	4279466931,	4279456643,
	4290490231,	4287598403,	4285228835,	4282598163,	4289957691,	4288375587,	4286532367,	4283905792,
	4287609827,	4284979139,	4283135915,	4281555855,	4280238967,	4279185243,	4278655807,	4278194987,
	4278192919,	4278915871,	4279442207,	4280230695,	4280757035,	4281545523,	4282071867,	4282598211,
	4282862411,	4283126615,	4283915103,	4284441447,	4285230963,	4286020475,	4287335303,	4284699483
};

public static TextureBuilder<byte> T => TextureBuilder.Create<byte>(TileWidth, TileHeight);

static ListStringCollection MapStrings = new();
static StringBuilder Script = new();
static int S(string text) => MapStrings.FindOrAdd(text);

void BuildNpcMap()
{
	
}

void Main()
{
	AssetSystem.LoadEvents();
	
	var font = MultiFont.Load(FontInfoPath, FontPngPath);
	var disk = new FileSystem();
	disk.CurrentDirectory = @"C:\Depot\bb\ualbion";
	var baseExchange = AssetSystem.SetupSimple(disk, AssetMapping.Global, new[] { "Base" });
	var testExchange = AssetSystem.SetupSimple(disk, AssetMapping.Global, new[] { "UATestDev" });
	var repackedExchange = AssetSystem.SetupSimple(disk, AssetMapping.Global, new[] { "Repacked" });

	var paletteId = (PaletteId)UAlbion.Base.Palette.Toronto2D;
	var font6 = font.GetFont(6);
	var font10 = font.GetFont(10);

	var commonRaw = new uint[256];
	var torontoRaw = new uint[256];
	Array.Copy(RawPalette, 192, commonRaw, 192, 64);
	Array.Copy(RawPalette, 0, torontoRaw, 0, 255);
	var common = new AlbionPalette(((PaletteId)UAlbion.Base.Palette.Common).ToUInt32(), null, commonRaw);
	var palette = new AlbionPalette(paletteId.ToUInt32(), paletteId.ToString(), torontoRaw);
	var ts = new TestTilemap(font6, font10);

	const int MapWidth = 255;
	const int MapHeight = 255;
	static int Pos(int x, int y) => y * MapWidth + x;

	for (int i = 0; i < 300; i++)
	{
		Script.AppendLine(@$"
{{
	Chain{i}:
	text {S($"Test string {i} ({i:X})")}
	change_language Tom SetToMaximum Celtic
}}
	");
	}
	
	MapId mapId = UAlbion.Base.Map.TorontoBegin;
	var compiled = AlbionCompiler.Compile(Script.ToString(), mapId.ToMapText());

	var map = new MapData2D(
		mapId,
		paletteId,
		ts.Tileset.Id,
		MapWidth, MapHeight,
		compiled, 
		new List<MapNpc>(),
		new List<MapEventZone>());
	map.Flags = 
		MapFlags.V2NpcData
		| MapFlags.Unk8000
		;

	Array.Fill(map.Underlay, ts.BlankOffset);
	Array.Fill(map.Overlay, 0);
	for (int i = 0; i < map.Underlay.Length; i++)
	{
		var y = i / map.Width;
		var x = i % map.Width;
		if (x == 0 || y == 0 || x == map.Width-1 || y == map.Height-1)
			map.Underlay[i] = ts.SolidOffset;
	}

/*
	const int cellW = 6;
	const int cellH = 7;
	const int cellSpacingX = 2;
	const int cellSpacingY = 2;
	const int cellArrayW = 16;
	const int cellArrayH = 16;
	MajMin(cellArrayW, cellArrayH, (majI, majJ) =>
	{
		int cellIndex = majJ * cellArrayW + majI;
		int x0 = majI * (cellW + cellSpacingX);
		int y0 = majJ * (cellH + cellSpacingY);

		MajMin(cellW, cellH, (i, j) =>
		{
			if (i == 0 || j == 0 || i == (cellW-1) || j == (cellH-1))
				map.Underlay[Pos(x0 + i, y0 + j)] = ts.SolidOffset; // Draw cell walls
		});

		map.Underlay[Pos(x0 + 1, y0 + 1)] = ts.UnderlayOffset + cellIndex; // Add marker
		map.AddZone((byte)(x0 + 1), (byte)(y0 + 1), TriggerTypes.Manipulate, (ushort)cellIndex);

		if (cellIndex != 0x83 && cellIndex != 0x84)
			return;
		
		var waypoints = BuildPatrolPath(x0+3, y0+6);
		map.Npcs.Add(new MapNpc {
			Id = (NpcId)UAlbion.Base.Npc.Cuarnainn, // (NpcId)(UAlbion.Base.Npc)(index+1),
			Type = NpcType.Npc,
			SpriteOrGroup = (SpriteId)UAlbion.Base.LargeNpc.Rainer, // (SpriteId)(UAlbion.Base.LargeNpc)(index+1),
			Flags = 0, // (NpcFlags.SimpleMsg), // (NpcFlags)index,
			Movement = NpcMovement.Waypoints,
			Waypoints = waypoints,
		});
	});
*/

	var assets = new Dictionary<AssetId, object>();
	assets[AssetId.FromUInt32(common.Id)] = common;
	assets[paletteId] = palette;
	assets[map.Id] = map;
	assets[map.Id.ToMapText()] = MapStrings;
	assets[ts.Tileset.Id] = ts.Tileset;
	assets[(SpriteId)ts.TilesetGfx.Id] = ts.TilesetGfx;
	
	(object asset, AssetInfo info) LoaderFunc(AssetId id, string lang) 
		=> assets.TryGetValue(id, out var asset) 
			? (asset, new AssetInfo(new Dictionary<string, object> { { AssetProperty.PaletteId, paletteId.Id } })) 
			: (null, null);

	// Create 3D lab graphics
	// Create 3D lab data
	// Create item data
	// Create player graphics
	//ts.TilesetGfx.ToBitmap().Dump();

	testExchange.Resolve<IModApplier>().SaveAssets(LoaderFunc, () => { }, assets.Keys.ToHashSet(), null, null);
	repackedExchange.Resolve<IModApplier>().SaveAssets(LoaderFunc, () => { }, assets.Keys.ToHashSet(), null, null);
	Console.WriteLine("Done");
}

public class TestTilemap
{
	public int BlankOffset { get; }
	public int SolidOffset { get; }
	public int UnderlayOffset { get; }
	public int OverlayOffset { get; }
	// public int FlagTileOffset { get; }
	public int SitOffset { get; }
	public int TextOffset { get; }
	public TilesetData Tileset { get; }
	public IReadOnlyTexture<byte> TilesetGfx { get; }
	public int IndexForChar(char c)
	{
		if (c < ' ' || c > '~') return 0;
		return (c - ' ') + TextOffset;
	}

	public TestTilemap(ITextureBuilderFont font, ITextureBuilderFont bigFont)
	{
		var tiles = new List<IReadOnlyTexture<byte>> {
			T.FillAll(CBlack1).Texture,
			T.FillAll(CBlack1).Texture,
			T.FillAll(CGrey12).Texture,
		};

		Tileset = new TilesetData(UAlbion.Base.Tileset.Toronto) { UseSmallGraphics = false };
		Tileset.Tiles.Add(new(Tileset.Tiles.Count, 1, TileType.Normal, TileLayer.Normal));
		BlankOffset = Tileset.Tiles.Count;
		Tileset.Tiles.Add(new(Tileset.Tiles.Count, 1, TileType.Normal, TileLayer.Normal));
		SolidOffset = Tileset.Tiles.Count;
		Tileset.Tiles.Add(new(Tileset.Tiles.Count, 2, TileType.Normal, TileLayer.Normal) { Collision = Passability.Solid });

		UnderlayOffset = Tileset.Tiles.Count;
		for (int i = 0; i < 16; i++)
		{
			for (int j = 0; j < 16; j++)
			{
				int gfxIndex = tiles.Count;
				tiles.Add(MakeTileGfx(false, (byte)(i * 16 + j), font));
				Tileset.Tiles.Add(new(Tileset.Tiles.Count, (ushort)gfxIndex, (TileType)i, (TileLayer)j));
			}
		}

		OverlayOffset = Tileset.Tiles.Count;
		for (int i = 0; i < 16; i++)
		{
			for (int j = 0; j < 16; j++)
			{
				int gfxIndex = tiles.Count;
				tiles.Add(MakeTileGfx(true, (byte)(i * 16 + j), font));
				Tileset.Tiles.Add(new(Tileset.Tiles.Count, (ushort)gfxIndex, (TileType)i, (TileLayer)j));
			}
		}

		SitOffset = Tileset.Tiles.Count;
		for (int i = 0; i < 16; i++)
		{
			int gfxIndex = tiles.Count;
			tiles.Add(T.FillAll(CGrey4)
				.Border(CWhite)
				.Text("S", CGreen5, 2, 2, font)
				.Text(i.ToString(), CGreen5, 2, 9, font)
				.Texture);

			Tileset.Tiles.Add(new(Tileset.Tiles.Count, (ushort)gfxIndex, 0, 0) { SitMode = (SitMode)i });
		}

		TextOffset = Tileset.Tiles.Count;
		for (int c = ' '; c <= '~'; c++)
		{
			int gfxIndex = tiles.Count;
			tiles.Add(T.FillAll(CGrey4)
				.Border(CWhite)
				.Text(c.ToString(), CGreen5, 2, 2, bigFont)
				.Texture);

			Tileset.Tiles.Add(new(Tileset.Tiles.Count, (ushort)gfxIndex, 0, 0) { });
		}

		TilesetGfx = BlitUtil.CombineFramesVertically((SpriteId)UAlbion.Base.TilesetGraphics.Toronto, tiles);
	}
}

static IReadOnlyTexture<byte> MakeTileGfx(bool overlay, byte num, ITextureBuilderFont font)
{
	var t = T.FillRect(overlay ? CBlue2 : CGrey6, 0, 0, TileWidth, overlay ? TileHeight / 2 : TileHeight);
	
	if (!overlay)
		t = t.Border(CGreen4);

	return 
		t.Text($"{num:X2}", CWhite, 2, overlay ? 2 : 9, font)
		.Texture;
}

public static class TextureExtensions
{
	const int Ratio = 4;
	static System.Drawing.Bitmap ToBitmapHelper<T>(IReadOnlyTexture<T> texture, Func<T, uint> converter) where T : unmanaged
	{
		var bmp = new System.Drawing.Bitmap(texture.Width * Ratio, texture.Height * Ratio);
		var data = bmp.LockBits(
			new System.Drawing.Rectangle(0, 0, bmp.Width, bmp.Height),
			System.Drawing.Imaging.ImageLockMode.WriteOnly,
			System.Drawing.Imaging.PixelFormat.Format32bppArgb);

		unsafe
		{
			var toSpan = new Span<uint>((void*)data.Scan0, data.Height * data.Stride);
			int pixelStride = data.Stride / sizeof(uint);
			var fromBuf = texture.GetLayerBuffer(0);
			for (int j = 0; j < fromBuf.Height; j++)
			{
				for (int i = 0; i < fromBuf.Width; i++)
				{
					var color = converter(fromBuf.Buffer[j * fromBuf.Stride + i]);
					var offset = (j * Ratio * pixelStride) + i * Ratio;
					for(int tj = 0; tj < Ratio; tj++)
						for (int ti = 0; ti < Ratio; ti++)
							toSpan[offset + tj * pixelStride + ti] = color;
				}
			}
		}

		bmp.UnlockBits(data);
		return bmp;
	}
	
	static uint Convert32(uint color)
	{
		var (r, g, b, a) = ApiUtil.UnpackColor(color);
		return ApiUtil.PackColor(b, g, r, a);
	}

	public static System.Drawing.Bitmap ToBitmap(this IReadOnlyTexture<uint> texture) => ToBitmapHelper(texture, Convert32);
	public static System.Drawing.Bitmap ToBitmap(this IReadOnlyTexture<byte> texture) => ToBitmapHelper(texture, color => Convert32(RawPalette[color]));
}

static NpcWaypoint[] BuildPatrolPath(int x0, int y0)
{
	var waypoints = new NpcWaypoint[MapNpc.WaypointCount];
	for (int i = 0; i < waypoints.Length; i++)
	{
		/* 7654
		   8  3
		   9012 */
		var (x, y) = (i % 8) switch
		{
			0 => (0, 0),
			1 => (1, 0),
			2 => (1, -1),
			3 => (1, -2),
			4 => (0, -2),
			5 => (-1, -2),
			6 => (-1, -1),
			_ => (-1, 0),
		};

		waypoints[i] = new NpcWaypoint((byte)(x0 + x), (byte)(y0 + y));
	}
	return waypoints;
}

static void MajMin(int min, int maj, Action<int, int> func)
{
	for (int j = 0; j < maj; j++)
		for (int i = 0; i < min; i++)
			func(i, j);
}